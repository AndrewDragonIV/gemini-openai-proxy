{
  "version": 3,
  "sources": ["../../../../.cache/deno/npm/registry.npmjs.org/@hono/node-server/1.14.1/dist/index.mjs", "../../../../.cache/deno/npm/registry.npmjs.org/itty-router/src/src/cors.ts", "../../../../.cache/deno/npm/registry.npmjs.org/itty-router/src/src/Router.ts", "../src/gemini-proxy.ts", "../src/utils.ts", "../src/hello.ts", "../src/log.ts", "../../../../.cache/deno/npm/registry.npmjs.org/eventsource-parser/3.0.1/src/errors.ts", "../../../../.cache/deno/npm/registry.npmjs.org/eventsource-parser/3.0.1/src/parse.ts", "../../../../.cache/deno/npm/registry.npmjs.org/eventsource-parser/3.0.1/src/stream.ts", "../src/gemini-api-client/errors.ts", "../src/gemini-api-client/gemini-api-client.ts", "../src/gemini-api-client/response-helper.ts", "../src/openai/chat/completions/NonStreamingChatProxyHandler.ts", "../src/openai/chat/completions/StreamingChatProxyHandler.ts", "../src/openai/chat/completions/ChatProxyHandler.ts", "../src/openai/embeddingProxyHandler.ts", "../src/openai/models.ts", "../src/app.ts", "../main_node.ts"],
  "sourcesContent": ["// src/server.ts\nimport { createServer as createServerHTTP } from \"http\";\n// src/request.ts\nimport { Http2ServerRequest } from \"http2\";\nimport { Readable } from \"stream\";\nvar RequestError = class extends Error {\n  static name = \"RequestError\";\n  constructor(message, options){\n    super(message, options);\n  }\n};\nvar toRequestError = (e)=>{\n  if (e instanceof RequestError) {\n    return e;\n  }\n  return new RequestError(e.message, {\n    cause: e\n  });\n};\nvar GlobalRequest = global.Request;\nvar Request = class extends GlobalRequest {\n  constructor(input, options){\n    if (typeof input === \"object\" && getRequestCache in input) {\n      input = input[getRequestCache]();\n    }\n    if (typeof options?.body?.getReader !== \"undefined\") {\n      ;\n      options.duplex ??= \"half\";\n    }\n    super(input, options);\n  }\n};\nvar newRequestFromIncoming = (method, url, incoming, abortController)=>{\n  const headerRecord = [];\n  const rawHeaders = incoming.rawHeaders;\n  for(let i = 0; i < rawHeaders.length; i += 2){\n    const { [i]: key, [i + 1]: value } = rawHeaders;\n    if (key.charCodeAt(0) !== /*:*/ 58) {\n      headerRecord.push([\n        key,\n        value\n      ]);\n    }\n  }\n  const init = {\n    method,\n    headers: headerRecord,\n    signal: abortController.signal\n  };\n  if (method === \"TRACE\") {\n    init.method = \"GET\";\n    const req = new Request(url, init);\n    Object.defineProperty(req, \"method\", {\n      get () {\n        return \"TRACE\";\n      }\n    });\n    return req;\n  }\n  if (!(method === \"GET\" || method === \"HEAD\")) {\n    if (\"rawBody\" in incoming && incoming.rawBody instanceof Buffer) {\n      init.body = new ReadableStream({\n        start (controller) {\n          controller.enqueue(incoming.rawBody);\n          controller.close();\n        }\n      });\n    } else {\n      init.body = Readable.toWeb(incoming);\n    }\n  }\n  return new Request(url, init);\n};\nvar getRequestCache = Symbol(\"getRequestCache\");\nvar requestCache = Symbol(\"requestCache\");\nvar incomingKey = Symbol(\"incomingKey\");\nvar urlKey = Symbol(\"urlKey\");\nvar abortControllerKey = Symbol(\"abortControllerKey\");\nvar getAbortController = Symbol(\"getAbortController\");\nvar requestPrototype = {\n  get method () {\n    return this[incomingKey].method || \"GET\";\n  },\n  get url () {\n    return this[urlKey];\n  },\n  [getAbortController] () {\n    this[getRequestCache]();\n    return this[abortControllerKey];\n  },\n  [getRequestCache] () {\n    this[abortControllerKey] ||= new AbortController();\n    return this[requestCache] ||= newRequestFromIncoming(this.method, this[urlKey], this[incomingKey], this[abortControllerKey]);\n  }\n};\n[\n  \"body\",\n  \"bodyUsed\",\n  \"cache\",\n  \"credentials\",\n  \"destination\",\n  \"headers\",\n  \"integrity\",\n  \"mode\",\n  \"redirect\",\n  \"referrer\",\n  \"referrerPolicy\",\n  \"signal\",\n  \"keepalive\"\n].forEach((k)=>{\n  Object.defineProperty(requestPrototype, k, {\n    get () {\n      return this[getRequestCache]()[k];\n    }\n  });\n});\n[\n  \"arrayBuffer\",\n  \"blob\",\n  \"clone\",\n  \"formData\",\n  \"json\",\n  \"text\"\n].forEach((k)=>{\n  Object.defineProperty(requestPrototype, k, {\n    value: function() {\n      return this[getRequestCache]()[k]();\n    }\n  });\n});\nObject.setPrototypeOf(requestPrototype, Request.prototype);\nvar newRequest = (incoming, defaultHostname)=>{\n  const req = Object.create(requestPrototype);\n  req[incomingKey] = incoming;\n  const incomingUrl = incoming.url || \"\";\n  if (incomingUrl[0] !== \"/\" && // short-circuit for performance. most requests are relative URL.\n  (incomingUrl.startsWith(\"http://\") || incomingUrl.startsWith(\"https://\"))) {\n    if (incoming instanceof Http2ServerRequest) {\n      throw new RequestError(\"Absolute URL for :path is not allowed in HTTP/2\");\n    }\n    try {\n      const url2 = new URL(incomingUrl);\n      req[urlKey] = url2.href;\n    } catch (e) {\n      throw new RequestError(\"Invalid absolute URL\", {\n        cause: e\n      });\n    }\n    return req;\n  }\n  const host = (incoming instanceof Http2ServerRequest ? incoming.authority : incoming.headers.host) || defaultHostname;\n  if (!host) {\n    throw new RequestError(\"Missing host header\");\n  }\n  let scheme;\n  if (incoming instanceof Http2ServerRequest) {\n    scheme = incoming.scheme;\n    if (!(scheme === \"http\" || scheme === \"https\")) {\n      throw new RequestError(\"Unsupported scheme\");\n    }\n  } else {\n    scheme = incoming.socket && incoming.socket.encrypted ? \"https\" : \"http\";\n  }\n  const url = new URL(`${scheme}://${host}${incomingUrl}`);\n  if (url.hostname.length !== host.length && url.hostname !== host.replace(/:\\d+$/, \"\")) {\n    throw new RequestError(\"Invalid host header\");\n  }\n  req[urlKey] = url.href;\n  return req;\n};\n// src/utils.ts\nfunction writeFromReadableStream(stream, writable) {\n  if (stream.locked) {\n    throw new TypeError(\"ReadableStream is locked.\");\n  } else if (writable.destroyed) {\n    stream.cancel();\n    return;\n  }\n  const reader = stream.getReader();\n  writable.on(\"close\", cancel);\n  writable.on(\"error\", cancel);\n  reader.read().then(flow, cancel);\n  return reader.closed.finally(()=>{\n    writable.off(\"close\", cancel);\n    writable.off(\"error\", cancel);\n  });\n  function cancel(error) {\n    reader.cancel(error).catch(()=>{});\n    if (error) {\n      writable.destroy(error);\n    }\n  }\n  function onDrain() {\n    reader.read().then(flow, cancel);\n  }\n  function flow({ done, value }) {\n    try {\n      if (done) {\n        writable.end();\n      } else if (!writable.write(value)) {\n        writable.once(\"drain\", onDrain);\n      } else {\n        return reader.read().then(flow, cancel);\n      }\n    } catch (e) {\n      cancel(e);\n    }\n  }\n}\nvar buildOutgoingHttpHeaders = (headers)=>{\n  const res = {};\n  if (!(headers instanceof Headers)) {\n    headers = new Headers(headers ?? void 0);\n  }\n  const cookies = [];\n  for (const [k, v] of headers){\n    if (k === \"set-cookie\") {\n      cookies.push(v);\n    } else {\n      res[k] = v;\n    }\n  }\n  if (cookies.length > 0) {\n    res[\"set-cookie\"] = cookies;\n  }\n  res[\"content-type\"] ??= \"text/plain; charset=UTF-8\";\n  return res;\n};\n// src/response.ts\nvar responseCache = Symbol(\"responseCache\");\nvar getResponseCache = Symbol(\"getResponseCache\");\nvar cacheKey = Symbol(\"cache\");\nvar GlobalResponse = global.Response;\nvar Response2 = class _Response {\n  #body;\n  #init;\n  [getResponseCache]() {\n    delete this[cacheKey];\n    return this[responseCache] ||= new GlobalResponse(this.#body, this.#init);\n  }\n  constructor(body, init){\n    this.#body = body;\n    if (init instanceof _Response) {\n      const cachedGlobalResponse = init[responseCache];\n      if (cachedGlobalResponse) {\n        this.#init = cachedGlobalResponse;\n        this[getResponseCache]();\n        return;\n      } else {\n        this.#init = init.#init;\n      }\n    } else {\n      this.#init = init;\n    }\n    if (typeof body === \"string\" || typeof body?.getReader !== \"undefined\") {\n      let headers = init?.headers || {\n        \"content-type\": \"text/plain; charset=UTF-8\"\n      };\n      if (headers instanceof Headers) {\n        headers = buildOutgoingHttpHeaders(headers);\n      }\n      ;\n      this[cacheKey] = [\n        init?.status || 200,\n        body,\n        headers\n      ];\n    }\n  }\n};\n[\n  \"body\",\n  \"bodyUsed\",\n  \"headers\",\n  \"ok\",\n  \"redirected\",\n  \"status\",\n  \"statusText\",\n  \"trailers\",\n  \"type\",\n  \"url\"\n].forEach((k)=>{\n  Object.defineProperty(Response2.prototype, k, {\n    get () {\n      return this[getResponseCache]()[k];\n    }\n  });\n});\n[\n  \"arrayBuffer\",\n  \"blob\",\n  \"clone\",\n  \"formData\",\n  \"json\",\n  \"text\"\n].forEach((k)=>{\n  Object.defineProperty(Response2.prototype, k, {\n    value: function() {\n      return this[getResponseCache]()[k]();\n    }\n  });\n});\nObject.setPrototypeOf(Response2, GlobalResponse);\nObject.setPrototypeOf(Response2.prototype, GlobalResponse.prototype);\nvar stateKey = Reflect.ownKeys(new GlobalResponse()).find((k)=>typeof k === \"symbol\" && k.toString() === \"Symbol(state)\");\nif (!stateKey) {\n  console.warn(\"Failed to find Response internal state key\");\n}\nfunction getInternalBody(response) {\n  if (!stateKey) {\n    return;\n  }\n  if (response instanceof Response2) {\n    response = response[getResponseCache]();\n  }\n  const state = response[stateKey];\n  return state && state.body || void 0;\n}\n// src/utils/response/constants.ts\nvar X_ALREADY_SENT = \"x-hono-already-sent\";\n// src/globals.ts\nimport crypto from \"crypto\";\nvar webFetch = global.fetch;\nif (typeof global.crypto === \"undefined\") {\n  global.crypto = crypto;\n}\nglobal.fetch = (info, init)=>{\n  init = {\n    // Disable compression handling so people can return the result of a fetch\n    // directly in the loader without messing with the Content-Encoding header.\n    compress: false,\n    ...init\n  };\n  return webFetch(info, init);\n};\n// src/listener.ts\nvar regBuffer = /^no$/i;\nvar regContentType = /^(application\\/json\\b|text\\/(?!event-stream\\b))/i;\nvar handleRequestError = ()=>new Response(null, {\n    status: 400\n  });\nvar handleFetchError = (e)=>new Response(null, {\n    status: e instanceof Error && (e.name === \"TimeoutError\" || e.constructor.name === \"TimeoutError\") ? 504 : 500\n  });\nvar handleResponseError = (e, outgoing)=>{\n  const err = e instanceof Error ? e : new Error(\"unknown error\", {\n    cause: e\n  });\n  if (err.code === \"ERR_STREAM_PREMATURE_CLOSE\") {\n    console.info(\"The user aborted a request.\");\n  } else {\n    console.error(e);\n    if (!outgoing.headersSent) {\n      outgoing.writeHead(500, {\n        \"Content-Type\": \"text/plain\"\n      });\n    }\n    outgoing.end(`Error: ${err.message}`);\n    outgoing.destroy(err);\n  }\n};\nvar responseViaCache = (res, outgoing)=>{\n  const [status, body, header] = res[cacheKey];\n  if (typeof body === \"string\") {\n    header[\"Content-Length\"] = Buffer.byteLength(body);\n    outgoing.writeHead(status, header);\n    outgoing.end(body);\n  } else {\n    outgoing.writeHead(status, header);\n    return writeFromReadableStream(body, outgoing)?.catch((e)=>handleResponseError(e, outgoing));\n  }\n};\nvar responseViaResponseObject = async (res, outgoing, options = {})=>{\n  if (res instanceof Promise) {\n    if (options.errorHandler) {\n      try {\n        res = await res;\n      } catch (err) {\n        const errRes = await options.errorHandler(err);\n        if (!errRes) {\n          return;\n        }\n        res = errRes;\n      }\n    } else {\n      res = await res.catch(handleFetchError);\n    }\n  }\n  if (cacheKey in res) {\n    return responseViaCache(res, outgoing);\n  }\n  const resHeaderRecord = buildOutgoingHttpHeaders(res.headers);\n  const internalBody = getInternalBody(res);\n  if (internalBody) {\n    const { length, source, stream } = internalBody;\n    if (source instanceof Uint8Array && source.byteLength !== length) {} else {\n      if (length) {\n        resHeaderRecord[\"content-length\"] = length;\n      }\n      outgoing.writeHead(res.status, resHeaderRecord);\n      if (typeof source === \"string\" || source instanceof Uint8Array) {\n        outgoing.end(source);\n      } else if (source instanceof Blob) {\n        outgoing.end(new Uint8Array(await source.arrayBuffer()));\n      } else {\n        await writeFromReadableStream(stream, outgoing);\n      }\n      return;\n    }\n  }\n  if (res.body) {\n    const { \"transfer-encoding\": transferEncoding, \"content-encoding\": contentEncoding, \"content-length\": contentLength, \"x-accel-buffering\": accelBuffering, \"content-type\": contentType } = resHeaderRecord;\n    if (transferEncoding || contentEncoding || contentLength || // nginx buffering variant\n    accelBuffering && regBuffer.test(accelBuffering) || !regContentType.test(contentType)) {\n      outgoing.writeHead(res.status, resHeaderRecord);\n      await writeFromReadableStream(res.body, outgoing);\n    } else {\n      const buffer = await res.arrayBuffer();\n      resHeaderRecord[\"content-length\"] = buffer.byteLength;\n      outgoing.writeHead(res.status, resHeaderRecord);\n      outgoing.end(new Uint8Array(buffer));\n    }\n  } else if (resHeaderRecord[X_ALREADY_SENT]) {} else {\n    outgoing.writeHead(res.status, resHeaderRecord);\n    outgoing.end();\n  }\n};\nvar getRequestListener = (fetchCallback, options = {})=>{\n  if (options.overrideGlobalObjects !== false && global.Request !== Request) {\n    Object.defineProperty(global, \"Request\", {\n      value: Request\n    });\n    Object.defineProperty(global, \"Response\", {\n      value: Response2\n    });\n  }\n  return async (incoming, outgoing)=>{\n    let res, req;\n    try {\n      req = newRequest(incoming, options.hostname);\n      outgoing.on(\"close\", ()=>{\n        const abortController = req[abortControllerKey];\n        if (!abortController) {\n          return;\n        }\n        if (incoming.errored) {\n          req[abortControllerKey].abort(incoming.errored.toString());\n        } else if (!outgoing.writableFinished) {\n          req[abortControllerKey].abort(\"Client connection prematurely closed.\");\n        }\n      });\n      res = fetchCallback(req, {\n        incoming,\n        outgoing\n      });\n      if (cacheKey in res) {\n        return responseViaCache(res, outgoing);\n      }\n    } catch (e) {\n      if (!res) {\n        if (options.errorHandler) {\n          res = await options.errorHandler(req ? e : toRequestError(e));\n          if (!res) {\n            return;\n          }\n        } else if (!req) {\n          res = handleRequestError();\n        } else {\n          res = handleFetchError(e);\n        }\n      } else {\n        return handleResponseError(e, outgoing);\n      }\n    }\n    try {\n      return await responseViaResponseObject(res, outgoing, options);\n    } catch (e) {\n      return handleResponseError(e, outgoing);\n    }\n  };\n};\n// src/server.ts\nvar createAdaptorServer = (options)=>{\n  const fetchCallback = options.fetch;\n  const requestListener = getRequestListener(fetchCallback, {\n    hostname: options.hostname,\n    overrideGlobalObjects: options.overrideGlobalObjects\n  });\n  const createServer = options.createServer || createServerHTTP;\n  const server = createServer(options.serverOptions || {}, requestListener);\n  return server;\n};\nvar serve = (options, listeningListener)=>{\n  const server = createAdaptorServer(options);\n  server.listen(options?.port ?? 3e3, options.hostname, ()=>{\n    const serverInfo = server.address();\n    listeningListener && listeningListener(serverInfo);\n  });\n  return server;\n};\nexport { RequestError, createAdaptorServer, getRequestListener, serve };\n", null, null, "export async function geminiProxy(rawReq: Request) {\n  const url = new URL(rawReq.url)\n  url.host = \"generativelanguage.googleapis.com\"\n  url.port = \"\"\n  url.protocol = \"https:\"\n  const req = new Request(url, rawReq)\n  const resp = await fetch(req)\n  return new Response(resp.body, resp)\n}\n", "import type { Content, GenerateContentRequest, JsonSchema, Part } from \"./gemini-api-client/types.ts\"\nimport type { Any } from \"./log.ts\"\nimport type { OpenAI } from \"./types.ts\"\n\nexport interface ApiParam {\n  apikey: string\n  useBeta: boolean\n}\n\nexport function getToken(headers: Iterable<[string, string]>): ApiParam | null {\n  for (const [k, v] of headers) {\n    if (k.toLowerCase() !== \"authorization\") continue\n\n    const rawApikey = v.substring(v.indexOf(\" \") + 1)\n\n    if (!rawApikey.includes(\"#\")) {\n      return {\n        apikey: rawApikey,\n        useBeta: false,\n      }\n    }\n\n    // todo read config from apikey\n    const apikey = rawApikey.substring(0, rawApikey.indexOf(\"#\"))\n    const params = new URLSearchParams(rawApikey.substring(rawApikey.indexOf(\"#\") + 1))\n    return {\n      apikey,\n      useBeta: params.has(\"useBeta\"),\n    }\n  }\n  return null\n}\n\nfunction parseBase64(base64: string): Part {\n  if (!base64.startsWith(\"data:\")) {\n    return { text: \"\" }\n  }\n\n  const [m, data, ..._arr] = base64.split(\",\")\n  const mimeType = m.match(/:(?<mime>.*?);/)?.groups?.mime ?? \"img/png\"\n  return {\n    inlineData: {\n      mimeType,\n      data,\n    },\n  }\n}\n\nexport function openAiMessageToGeminiMessage(messages: OpenAI.Chat.ChatCompletionMessageParam[]): Content[] {\n  const result: Content[] = messages.flatMap(({ role, content }) => {\n    if (role === \"system\") {\n      return [\n        {\n          role: \"user\",\n          parts: typeof content !== \"string\" ? content : [{ text: content }],\n        },\n      ] satisfies Content[] as Content[]\n    }\n    const parts: Part[] =\n      content == null || typeof content === \"string\"\n        ? [{ text: content?.toString() ?? \"\" }]\n        : content.map((item) => {\n            if (item.type === \"text\") return { text: item.text }\n            if (item.type === \"image_url\") return parseBase64(item.image_url.url)\n            return { text: \"OK\" }\n          })\n    return [{ role: \"user\" === role ? \"user\" : \"model\", parts: parts }]\n  })\n\n  return result\n}\n\nexport function genModel(req: OpenAI.Chat.ChatCompletionCreateParams): [GeminiModel, GenerateContentRequest] {\n  const model: GeminiModel = GeminiModel.modelMapping(req.model)\n\n  let functions: OpenAI.Chat.FunctionObject[] =\n    req.tools?.filter((it) => it.type === \"function\")?.map((it) => it.function) ?? []\n\n  functions = functions.concat((req.functions ?? []).map((it) => ({ strict: null, ...it })))\n\n  const [responseMimeType, responseSchema] = (() => {\n    switch (req.response_format?.type) {\n      case \"json_object\":\n        return [\"application/json\", undefined]\n      case \"json_schema\":\n        return [\"application/json\", req.response_format.json_schema.schema satisfies JsonSchema | undefined]\n      case \"text\":\n        return [\"text/plain\", undefined]\n      default:\n        return [undefined, undefined]\n    }\n  })()\n\n  const generateContentRequest: GenerateContentRequest = {\n    contents: openAiMessageToGeminiMessage(req.messages),\n    generationConfig: {\n      maxOutputTokens: req.max_completion_tokens ?? undefined,\n      temperature: req.temperature ?? undefined,\n      topP: req.top_p ?? undefined,\n      responseMimeType: responseMimeType,\n      responseSchema: responseSchema,\n      thinkingConfig: !model.isThinkingModel()\n        ? undefined\n        : {\n            includeThoughts: true,\n          },\n    },\n    tools:\n      functions.length === 0\n        ? undefined\n        : [\n            {\n              functionDeclarations: functions,\n            },\n          ],\n    safetySettings: (\n      [\n        \"HARM_CATEGORY_HATE_SPEECH\",\n        \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n        \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n        \"HARM_CATEGORY_HARASSMENT\",\n      ] as const\n    ).map((category) => ({\n      category,\n      threshold: \"BLOCK_NONE\",\n    })),\n  }\n  return [model, generateContentRequest]\n}\nexport type KnownGeminiModel =\n  | \"gemini-1.5-pro-latest\"\n  | \"gemini-1.5-flash-latest\"\n  | \"gemini-1.5-flash-8b-latest\"\n  | \"gemini-2.0-flash-exp\"\n  | \"text-embedding-004\"\n\nexport type API_VERSION = \"v1beta\" | \"v1\" | \"v1alpha\"\n\nexport class GeminiModel {\n  static modelMapping(model: string | undefined): GeminiModel {\n    const modelName: GeminiModelName | KnownGeminiModel =\n      ModelMapping[model ?? \"\"] ?? GeminiModel.defaultModel(model ?? \"\")\n    return new GeminiModel(modelName)\n  }\n  public readonly model: GeminiModelName\n  constructor(model: GeminiModelName) {\n    this.model = model\n  }\n\n  isThinkingModel(): boolean {\n    return this.model.includes(\"thinking\")\n  }\n\n  apiVersion(): API_VERSION {\n    if (this.isThinkingModel()) {\n      return \"v1alpha\"\n    }\n    return \"v1beta\"\n  }\n\n  toString(): string {\n    return this.model\n  }\n\n  private static defaultModel(m: string): GeminiModelName {\n    if (m.startsWith(\"gemini\")) {\n      return m as GeminiModelName\n    }\n    return \"gemini-1.5-flash-latest\"\n  }\n}\n\nexport type GeminiModelName = `gemini${string}` | \"text-embedding-004\"\n\nexport const ModelMapping: Readonly<Record<string, KnownGeminiModel>> = {\n  \"gpt-3.5-turbo\": \"gemini-1.5-flash-8b-latest\",\n  \"gpt-4\": \"gemini-1.5-pro-latest\",\n  \"gpt-4o\": \"gemini-1.5-flash-latest\",\n  \"gpt-4o-mini\": \"gemini-1.5-flash-8b-latest\",\n  \"gpt-4-vision-preview\": \"gemini-1.5-flash-latest\",\n  \"gpt-4-turbo\": \"gemini-1.5-pro-latest\",\n  \"gpt-4-turbo-preview\": \"gemini-2.0-flash-exp\",\n}\n\nexport function getRuntimeKey() {\n  const global = globalThis as typeof globalThis & Record<string, undefined | Any>\n  if (global?.Deno !== undefined) {\n    return \"deno\"\n  }\n  if (global?.Bun !== undefined) {\n    return \"bun\"\n  }\n  if (typeof global?.WebSocketPair === \"function\") {\n    return \"workerd\"\n  }\n  if (typeof global?.EdgeRuntime === \"string\") {\n    return \"edge-light\"\n  }\n  if (global?.fastly !== undefined) {\n    return \"fastly\"\n  }\n  if (global?.process?.release?.name === \"node\") {\n    return \"node\"\n  }\n  return \"other\"\n}\n", "import { getRuntimeKey } from \"./utils.ts\"\n\nexport function hello(req: Request): Response {\n  const origin = new URL(req.url).origin\n  return new Response(`\n    Hello Gemini-OpenAI-Proxy from ${getRuntimeKey()}!\n\n    You can try it with:\n\n    curl ${origin}/v1/chat/completions \\\\\n    -H \"Authorization: Bearer $YOUR_GEMINI_API_KEY\" \\\\\n    -H \"Content-Type: application/json\" \\\\\n    -d '{\n        \"model\": \"gpt-3.5-turbo\",\n        \"messages\": [{\"role\": \"user\", \"content\": \"Hello\"}],\n        \"temperature\": 0.7\n    }'\n    `)\n}\n", "export type Any = Parameters<typeof console.log>[0]\n\nexport interface ILogger {\n  error: (...data: Any[]) => void\n  warn: (...data: Any[]) => void\n  info: (...data: Any[]) => void\n  debug: (...data: Any[]) => void\n}\n\nconst LEVEL = [\"debug\", \"info\", \"warn\", \"error\"] as const\n\ninterface Config {\n  level: (typeof LEVEL)[number]\n  prefix: string\n}\n\nexport class Logger implements ILogger {\n  private config: Config\n\n  debug!: Log\n  info!: Log\n  warn!: Log\n  error!: Log\n\n  constructor(prefix?: string, logLevel?: string) {\n    const level = LEVEL.find((it) => it === logLevel) ?? \"warn\"\n    this.config = {\n      prefix: prefix ?? \"\",\n      level,\n    }\n\n    for (const m of LEVEL) {\n      this[m] = (...data: Any[]) => this.#write(m, ...data)\n    }\n  }\n\n  #write(level: Config[\"level\"], ...data: Any[]) {\n    const { level: configLevel, prefix } = this.config\n    if (LEVEL.indexOf(level) < LEVEL.indexOf(configLevel)) {\n      return\n    }\n\n    console[level](`${new Date().toISOString()} ${level.toUpperCase()}${prefix ? ` ${prefix}` : \"\"}`, ...data)\n  }\n}\n\ntype Log = typeof console.log\n", "/**\n * The type of error that occurred.\n * @public\n */\nexport type ErrorType = 'invalid-retry' | 'unknown-field'\n\n/**\n * Error thrown when encountering an issue during parsing.\n *\n * @public\n */\nexport class ParseError extends Error {\n  /**\n   * The type of error that occurred.\n   */\n  type: ErrorType\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the field name.\n   */\n  field?: string\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the value of the field.\n   */\n  value?: string\n\n  /**\n   * The line that caused the error, if available.\n   */\n  line?: string\n\n  constructor(\n    message: string,\n    options: {type: ErrorType; field?: string; value?: string; line?: string},\n  ) {\n    super(message)\n    this.name = 'ParseError'\n    this.type = options.type\n    this.field = options.field\n    this.value = options.value\n    this.line = options.line\n  }\n}\n", "/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nimport {ParseError} from './errors.ts'\nimport type {EventSourceParser, ParserCallbacks} from './types.ts'\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction noop(_arg: unknown) {\n  // intentional noop\n}\n\n/**\n * Creates a new EventSource parser.\n *\n * @param callbacks - Callbacks to invoke on different parsing events:\n *   - `onEvent` when a new event is parsed\n *   - `onError` when an error occurs\n *   - `onRetry` when a new reconnection interval has been sent from the server\n *   - `onComment` when a comment is encountered in the stream\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(callbacks: ParserCallbacks): EventSourceParser {\n  if (typeof callbacks === 'function') {\n    throw new TypeError(\n      '`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?',\n    )\n  }\n\n  const {onEvent = noop, onError = noop, onRetry = noop, onComment} = callbacks\n\n  let incompleteLine = ''\n\n  let isFirstChunk = true\n  let id: string | undefined\n  let data = ''\n  let eventType = ''\n\n  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }\n\n  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    // 👆 This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }\n\n  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}…` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }\n\n  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }\n\n  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    isFirstChunk = true\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }\n\n  return {feed, reset}\n}\n\n/**\n * For the given `chunk`, split it into lines according to spec, and return any remaining incomplete line.\n *\n * @param chunk - The chunk to split into lines\n * @returns A tuple containing an array of complete lines, and any remaining incomplete line\n * @internal\n */\nfunction splitLines(chunk: string): [complete: Array<string>, incomplete: string] {\n  /**\n   * According to the spec, a line is terminated by either:\n   * - U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair\n   * - a single U+000A LINE FEED(LF) character not preceded by a U+000D CARRIAGE RETURN(CR) character\n   * - a single U+000D CARRIAGE RETURN(CR) character not followed by a U+000A LINE FEED(LF) character\n   */\n  const lines: Array<string> = []\n  let incompleteLine = ''\n  let searchIndex = 0\n\n  while (searchIndex < chunk.length) {\n    // Find next line terminator\n    const crIndex = chunk.indexOf('\\r', searchIndex)\n    const lfIndex = chunk.indexOf('\\n', searchIndex)\n\n    // Determine line end\n    let lineEnd = -1\n    if (crIndex !== -1 && lfIndex !== -1) {\n      // CRLF case\n      lineEnd = Math.min(crIndex, lfIndex)\n    } else if (crIndex !== -1) {\n      lineEnd = crIndex\n    } else if (lfIndex !== -1) {\n      lineEnd = lfIndex\n    }\n\n    // Extract line if terminator found\n    if (lineEnd === -1) {\n      // No terminator found, rest is incomplete\n      incompleteLine = chunk.slice(searchIndex)\n      break\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd)\n      lines.push(line)\n\n      // Move past line terminator\n      searchIndex = lineEnd + 1\n      if (chunk[searchIndex - 1] === '\\r' && chunk[searchIndex] === '\\n') {\n        searchIndex++\n      }\n    }\n  }\n\n  return [lines, incompleteLine]\n}\n", "import {createParser} from './parse.ts'\nimport type {EventSourceMessage, EventSourceParser} from './types.ts'\n\n/**\n * Options for the EventSourceParserStream.\n *\n * @public\n */\nexport interface StreamOptions {\n  /**\n   * Behavior when a parsing error occurs.\n   *\n   * - A custom function can be provided to handle the error.\n   * - `'terminate'` will error the stream and stop parsing.\n   * - Any other value will ignore the error and continue parsing.\n   *\n   * @defaultValue `undefined`\n   */\n  onError?: 'terminate' | ((error: Error) => void)\n\n  /**\n   * Callback for when a reconnection interval is sent from the server.\n   *\n   * @param retry - The number of milliseconds to wait before reconnecting.\n   */\n  onRetry?: (retry: number) => void\n\n  /**\n   * Callback for when a comment is encountered in the stream.\n   *\n   * @param comment - The comment encountered in the stream.\n   */\n  onComment?: (comment: string) => void\n}\n\n/**\n * A TransformStream that ingests a stream of strings and produces a stream of `EventSourceMessage`.\n *\n * @example Basic usage\n * ```\n * const eventStream =\n *   response.body\n *     .pipeThrough(new TextDecoderStream())\n *     .pipeThrough(new EventSourceParserStream())\n * ```\n *\n * @example Terminate stream on parsing errors\n * ```\n * const eventStream =\n *  response.body\n *   .pipeThrough(new TextDecoderStream())\n *   .pipeThrough(new EventSourceParserStream({terminateOnError: true}))\n * ```\n *\n * @public\n */\nexport class EventSourceParserStream extends TransformStream<string, EventSourceMessage> {\n  constructor({onError, onRetry, onComment}: StreamOptions = {}) {\n    let parser!: EventSourceParser\n\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: (event) => {\n            controller.enqueue(event)\n          },\n          onError(error) {\n            if (onError === 'terminate') {\n              controller.error(error)\n            } else if (typeof onError === 'function') {\n              onError(error)\n            }\n\n            // Ignore by default\n          },\n          onRetry,\n          onComment,\n        })\n      },\n      transform(chunk) {\n        parser.feed(chunk)\n      },\n    })\n  }\n}\n\nexport {type ErrorType, ParseError} from './errors.ts'\nexport type {EventSourceMessage} from './types.ts'\n", "export class GoogleGenerativeAIError extends Error {\n  constructor(message: string) {\n    super(`[GoogleGenerativeAI Error]: ${message}`)\n  }\n}\n\nexport class GoogleGenerativeAIResponseError<T> extends GoogleGenerativeAIError {\n  public response?: T\n  constructor(message: string, response?: T) {\n    super(message)\n    this.response = response\n  }\n}\n", "import { EventSourceParserStream } from \"eventsource-parser/stream\"\nimport type { components } from \"../generated-types/gemini-types.ts\"\nimport type { ApiParam, GeminiModel } from \"../utils.ts\"\nimport { GoogleGenerativeAIError } from \"./errors.ts\"\nimport type {\n  EmbedContentRequest,\n  EmbedContentResponse,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  RequestOptions,\n} from \"./types.ts\"\n\ninterface Task {\n  streamGenerateContent: {\n    request: GenerateContentRequest\n    response: GenerateContentResponse\n  }\n  embedContent: {\n    request: EmbedContentRequest\n    response: EmbedContentResponse\n  }\n}\n\nexport async function listModels(apiParam: ApiParam | null) {\n  const url = new URL(`${BASE_URL}/v1beta/openai/models`)\n  const resp = await makeRequest(url, undefined, undefined, \"GET\", {\n    Authorization: `Bearer ${apiParam?.apikey ?? \"\"}`,\n  })\n  return (await resp.json()) as components[\"schemas\"][\"ListModelsResponse\"]\n}\nexport async function* streamGenerateContent(\n  apiParam: ApiParam,\n  model: GeminiModel,\n  params: Task[\"streamGenerateContent\"][\"request\"],\n  requestOptions?: RequestOptions,\n) {\n  const response = await makeRequest(\n    toURL({ model, task: \"streamGenerateContent\", stream: true, apiParam }),\n    JSON.stringify(params),\n    requestOptions,\n  )\n  const body = response.body\n  if (body == null) {\n    return\n  }\n\n  for await (const event of body.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream())) {\n    const responseJson = JSON.parse(event.data) as Task[\"streamGenerateContent\"][\"response\"]\n    yield responseJson\n  }\n}\n\nexport async function embedContent(\n  apiParam: ApiParam,\n  model: GeminiModel,\n  params: Task[\"embedContent\"][\"request\"],\n  requestOptions?: RequestOptions,\n) {\n  const response = await makeRequest(\n    toURL({ model, task: \"embedContent\", stream: false, apiParam }),\n    JSON.stringify(params),\n    requestOptions,\n  )\n  const body = response.body\n  if (body == null) {\n    return\n  }\n\n  const responseJson = (await response.json()) as Task[\"embedContent\"][\"response\"]\n  return responseJson\n}\n\nasync function makeRequest(\n  url: URL,\n  body: string | undefined,\n  requestOptions?: RequestOptions,\n  requestMethod = \"POST\",\n  headers: Record<string, string> = {},\n): Promise<Response> {\n  let response: Response\n  try {\n    response = await fetch(url, {\n      ...buildFetchOptions(requestOptions),\n      method: requestMethod,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers,\n      },\n      body,\n    })\n    if (!response.ok) {\n      let message: string | undefined = \"\"\n      try {\n        const errResp = (await response.json()) as components[\"schemas\"][\"Operation\"]\n        message = errResp.error?.message\n        if (errResp?.error?.details) {\n          message += ` ${JSON.stringify(errResp.error.details)}`\n        }\n      } catch (_e) {\n        // ignored\n      }\n      throw new Error(`[${response.status} ${response.statusText}] ${message}`)\n    }\n  } catch (e) {\n    console.log(e)\n    const err = new GoogleGenerativeAIError(`Error fetching from google -> ${e.message}`)\n    err.stack = e.stack\n    throw err\n  }\n  return response\n}\n\nconst BASE_URL = \"https://generativelanguage.googleapis.com\"\n\nfunction toURL({\n  model,\n  task,\n  stream,\n  apiParam,\n}: {\n  model: GeminiModel\n  task: keyof Task\n  stream: boolean\n  apiParam: ApiParam\n}) {\n  const api_version = model.apiVersion()\n  const url = new URL(`${BASE_URL}/${api_version}/models/${model}:${task}`)\n  url.searchParams.append(\"key\", apiParam.apikey)\n  if (stream) {\n    url.searchParams.append(\"alt\", \"sse\")\n  }\n  return url\n}\n\n/**\n * Generates the request options to be passed to the fetch API.\n * @param requestOptions - The user-defined request options.\n * @returns The generated request options.\n */\nfunction buildFetchOptions(requestOptions?: RequestOptions): RequestInit {\n  const fetchOptions = {} as RequestInit\n  if (requestOptions?.timeout) {\n    const abortController = new AbortController()\n    const signal = abortController.signal\n    setTimeout(() => abortController.abort(), requestOptions.timeout)\n    fetchOptions.signal = signal\n  }\n  return fetchOptions\n}\n", "import { GoogleGenerativeAIResponseError } from \"./errors.ts\"\nimport type { Candidate, FinishReason, FunctionCall, GenerateContentResponse } from \"./types.ts\"\n\n/**\n * Adds convenience helper methods to a response object, including stream\n * chunks (as long as each chunk is a complete GenerateContentResponse JSON).\n */\nexport function resultHelper(response: GenerateContentResponse): string | FunctionCall {\n  if (response.candidates && response.candidates.length > 0) {\n    if (response.candidates.length > 1) {\n      console.warn(\n        `This response had ${response.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`,\n      )\n    }\n    if (hadBadFinishReason(response.candidates[0])) {\n      throw new GoogleGenerativeAIResponseError<GenerateContentResponse>(\n        `${formatBlockErrorMessage(response)}`,\n        response,\n      )\n    }\n    return getText(response)\n  }\n  if (response.promptFeedback) {\n    throw new GoogleGenerativeAIResponseError<GenerateContentResponse>(\n      `Text not available. ${formatBlockErrorMessage(response)}`,\n      response,\n    )\n  }\n  return \"\"\n}\n\n/**\n * Returns text of first candidate.\n */\nexport function getText(response: GenerateContentResponse): string | FunctionCall {\n  if (response.candidates?.[0].content?.parts?.[0]?.text) {\n    return response.candidates[0].content.parts[0].text\n  }\n  if (response.candidates?.[0].content?.parts?.[0]?.functionCall) {\n    return response.candidates[0].content.parts[0].functionCall\n  }\n  return \"\"\n}\n\nconst badFinishReasons: FinishReason[] = [\"RECITATION\", \"SAFETY\"]\n\nfunction hadBadFinishReason(candidate: Candidate): boolean {\n  return !!candidate.finishReason && badFinishReasons.includes(candidate.finishReason)\n}\n\nfunction formatBlockErrorMessage(response: GenerateContentResponse): string {\n  let message = \"\"\n  if ((!response.candidates || response.candidates.length === 0) && response.promptFeedback) {\n    message += \"Response was blocked\"\n    if (response.promptFeedback?.blockReason) {\n      message += ` due to ${response.promptFeedback.blockReason}`\n    }\n    if (response.promptFeedback?.blockReasonMessage) {\n      message += `: ${response.promptFeedback.blockReasonMessage}`\n    }\n  } else if (response.candidates?.[0]) {\n    const firstCandidate = response.candidates[0]\n    if (hadBadFinishReason(firstCandidate)) {\n      message += `Candidate was blocked due to ${firstCandidate.finishReason}`\n      if (firstCandidate.finishMessage) {\n        message += `: ${firstCandidate.finishMessage}`\n      }\n    }\n  }\n  return message\n}\n", "import { streamGenerateContent } from \"../../../gemini-api-client/gemini-api-client.ts\"\nimport { resultHelper } from \"../../../gemini-api-client/response-helper.ts\"\nimport type { FunctionCall } from \"../../../gemini-api-client/types.ts\"\nimport type { Logger } from \"../../../log.ts\"\nimport type { OpenAI } from \"../../../types.ts\"\nimport { type ApiParam, genModel } from \"../../../utils.ts\"\n\nexport async function nonStreamingChatProxyHandler(\n  req: OpenAI.Chat.ChatCompletionCreateParams,\n  apiParam: ApiParam,\n  log?: Logger,\n): Promise<Response> {\n  const [model, geminiReq] = genModel(req)\n  let geminiResp: string | FunctionCall = \"\"\n\n  try {\n    for await (const it of streamGenerateContent(apiParam, model, geminiReq)) {\n      const data = resultHelper(it)\n      if (typeof data === \"string\") {\n        geminiResp += data\n      } else {\n        geminiResp = data\n        break\n      }\n    }\n  } catch (err) {\n    // 出现异常时打印请求参数和响应，以便调试\n    log?.error(req)\n    log?.error(err?.message ?? err.toString())\n    geminiResp = err?.message ?? err.toString()\n  }\n\n  log?.debug(req)\n  log?.debug(geminiResp)\n\n  function genOpenAiResp(content: string | FunctionCall): OpenAI.Chat.ChatCompletion {\n    if (typeof content === \"string\") {\n      return {\n        id: \"chatcmpl-abc123\",\n        object: \"chat.completion\",\n        created: Math.floor(Date.now() / 1000),\n        model: model.model,\n        choices: [\n          {\n            message: { role: \"assistant\", content: content, refusal: null },\n            finish_reason: \"stop\",\n            index: 0,\n            logprobs: null,\n          },\n        ],\n      }\n    }\n\n    return {\n      id: \"chatcmpl-abc123\",\n      object: \"chat.completion\",\n      created: Math.floor(Date.now() / 1000),\n      model: model.model,\n      choices: [\n        {\n          message: {\n            role: \"assistant\",\n            refusal: null,\n            content: null,\n            function_call: {\n              name: content.name ?? \"\",\n              arguments: JSON.stringify(content.args),\n            },\n          },\n          finish_reason: \"function_call\",\n          index: 0,\n          logprobs: null,\n        },\n      ],\n    }\n  }\n\n  return Response.json(genOpenAiResp(geminiResp))\n}\n", "import { streamGenerateContent } from \"../../../gemini-api-client/gemini-api-client.ts\"\nimport { resultHelper } from \"../../../gemini-api-client/response-helper.ts\"\nimport type { FunctionCall } from \"../../../gemini-api-client/types.ts\"\nimport type { Logger } from \"../../../log.ts\"\nimport type { OpenAI } from \"../../../types.ts\"\nimport { type ApiParam, genModel } from \"../../../utils.ts\"\n\nexport function streamingChatProxyHandler(\n  req: OpenAI.Chat.ChatCompletionCreateParams,\n  apiParam: ApiParam,\n  log?: Logger,\n): Response {\n  const [model, geminiReq] = genModel(req)\n  log?.debug(\"streamGenerateContent request\", req)\n  return sseResponse(\n    (async function* () {\n      try {\n        for await (const it of streamGenerateContent(apiParam, model, geminiReq)) {\n          log?.debug(\"streamGenerateContent resp\", it)\n          const data = resultHelper(it)\n          yield genStreamResp({\n            model: model.model,\n            content: data,\n            stop: false,\n          })\n        }\n      } catch (error) {\n        yield genStreamResp({\n          model: model.model,\n          content: error?.message ?? error.toString(),\n          stop: true,\n        })\n      }\n      yield genStreamResp({ model: model.model, content: \"\", stop: true })\n      yield \"[DONE]\"\n      return undefined\n    })(),\n  )\n}\n\nfunction genStreamResp({\n  model,\n  content,\n  stop,\n}: {\n  model: string\n  content: string | FunctionCall\n  stop: boolean\n}): OpenAI.Chat.ChatCompletionChunk {\n  if (typeof content === \"string\") {\n    return {\n      id: \"chatcmpl-abc123\",\n      object: \"chat.completion.chunk\",\n      created: Math.floor(Date.now() / 1000),\n      model: model,\n      choices: [\n        {\n          delta: { role: \"assistant\", content },\n          finish_reason: stop ? \"stop\" : null,\n          index: 0,\n        },\n      ],\n    } satisfies OpenAI.Chat.ChatCompletionChunk\n  }\n\n  return {\n    id: \"chatcmpl-abc123\",\n    object: \"chat.completion.chunk\",\n    created: Math.floor(Date.now() / 1000),\n    model: model,\n    choices: [\n      {\n        delta: { role: \"assistant\", function_call: content },\n        finish_reason: stop ? \"function_call\" : null,\n        index: 0,\n      },\n    ],\n  } satisfies OpenAI.Chat.ChatCompletionChunk\n}\n\nconst encoder = new TextEncoder()\n\nfunction sseResponse(dataStream: AsyncGenerator<string | OpenAI.Chat.ChatCompletionChunk, undefined>): Response {\n  const s = new ReadableStream<Uint8Array>({\n    async pull(controller) {\n      const { value, done } = await dataStream.next()\n      if (done) {\n        controller.close()\n      } else {\n        const data = typeof value === \"string\" ? value : JSON.stringify(value)\n        controller.enqueue(encoder.encode(toSseMsg({ data })))\n      }\n    },\n  })\n\n  const response = new Response(s, {\n    status: 200,\n    headers: new Headers({\n      \"Content-Type\": \"text/event-stream\",\n    }),\n  })\n\n  return response\n}\n\nexport function toSseMsg({ event, data, id }: SseEvent) {\n  let result = `data: ${data}\\n`\n  if (event) {\n    result += `event: ${event ?? \"\"}\\n`\n  }\n  if (id) {\n    result += `id: ${id ?? \"\"}\\n`\n  }\n  return `${result}\\n`\n}\n\nexport interface SseEvent {\n  event?: string\n  id?: string\n  data: string\n}\n", "import type { OpenAI } from \"../../../types.ts\"\nimport { getToken } from \"../../../utils.ts\"\nimport { nonStreamingChatProxyHandler } from \"./NonStreamingChatProxyHandler.ts\"\nimport { streamingChatProxyHandler } from \"./StreamingChatProxyHandler.ts\"\n\nexport async function chatProxyHandler(rawReq: Request): Promise<Response> {\n  const req = (await rawReq.json()) as OpenAI.Chat.ChatCompletionCreateParams\n  const headers = rawReq.headers\n  const apiParam = getToken(headers)\n  if (apiParam == null) {\n    return new Response(\"Unauthorized\", { status: 401 })\n  }\n\n  if (req.stream !== true) {\n    return await nonStreamingChatProxyHandler(req, apiParam, rawReq.logger)\n  }\n  return streamingChatProxyHandler(req, apiParam, rawReq.logger)\n}\n", "import { embedContent } from \"../gemini-api-client/gemini-api-client.ts\"\nimport type { EmbedContentRequest } from \"../gemini-api-client/types.ts\"\nimport type { OpenAI } from \"../types.ts\"\nimport { GeminiModel, getToken } from \"../utils.ts\"\n\nexport async function embeddingProxyHandler(rawReq: Request): Promise<Response> {\n  const req = (await rawReq.json()) as OpenAI.Embeddings.EmbeddingCreateParams\n  const log = rawReq.logger\n  const headers = rawReq.headers\n  const apiParam = getToken(headers)\n  if (apiParam == null) {\n    return new Response(\"Unauthorized\", { status: 401 })\n  }\n\n  const embedContentRequest: EmbedContentRequest = {\n    model: \"models/text-embedding-004\",\n    content: {\n      parts: [req.input].flat().map((it) => ({ text: it.toString() })),\n    },\n  }\n\n  log?.warn(\"request\", embedContentRequest)\n\n  let geminiResp: number[] | undefined = []\n\n  try {\n    const it = await embedContent(apiParam, new GeminiModel(\"text-embedding-004\"), embedContentRequest)\n    const data = it?.embedding?.values\n    geminiResp = data\n  } catch (err) {\n    // 出现异常时打印请求参数和响应，以便调试\n    log?.error(req)\n    log?.error(err?.message ?? err.toString())\n    geminiResp = err?.message ?? err.toString()\n  }\n\n  log?.debug(req)\n  log?.debug(geminiResp)\n\n  const resp: OpenAI.Embeddings.CreateEmbeddingResponse = {\n    object: \"list\",\n    data: [\n      {\n        object: \"embedding\",\n        index: 0,\n        embedding: geminiResp ?? [],\n      },\n    ],\n    model: req.model,\n    usage: {\n      prompt_tokens: 5,\n      total_tokens: 5,\n    },\n  }\n\n  return Response.json(resp)\n}\n", "import { listModels } from \"../gemini-api-client/gemini-api-client.ts\"\nimport type { OpenAI } from \"../types.ts\"\nimport { getToken, ModelMapping } from \"../utils.ts\"\nexport const modelData: OpenAI.Models.Model[] = Object.keys(ModelMapping).map((model) => ({\n  created: 1677610602,\n  object: \"model\",\n  owned_by: \"openai\",\n  id: model,\n}))\n\nexport const models = async (req: Request) => {\n  const apiParam = getToken(req.headers)\n  return await listModels(apiParam)\n\n  // return {\n  //   object: \"list\",\n  //   data: modelData,\n  // }\n}\n\nexport const modelDetail = (model: string) => {\n  return modelData.find((it) => it.id === model)\n}\n", "import type { IRequest } from \"itty-router/\"\nimport { cors } from \"itty-router/cors\"\nimport { Router } from \"itty-router/Router\"\nimport { geminiProxy } from \"./gemini-proxy.ts\"\nimport { hello } from \"./hello.ts\"\nimport { type Any, Logger } from \"./log.ts\"\nimport { chatProxyHandler } from \"./openai/chat/completions/ChatProxyHandler.ts\"\nimport { embeddingProxyHandler } from \"./openai/embeddingProxyHandler.ts\"\nimport { modelDetail, models } from \"./openai/models.ts\"\n\nconst { preflight, corsify } = cors({ allowHeaders: \"*\" })\n\nconst app = Router<IRequest, Any[], Response>({\n  before: [\n    preflight,\n    (req) => {\n      req.logger = new Logger(crypto.randomUUID().toString())\n      req.logger.warn(`--> ${req.method} ${req.url}`)\n    },\n  ],\n  finally: [\n    corsify,\n    (_, req) => {\n      req.logger?.warn(`<-- ${req.method} ${req.url}`)\n      // return resp\n    },\n  ],\n})\n\napp.get(\"/\", hello)\napp.post(\"/v1/chat/completions\", chatProxyHandler)\napp.post(\"/v1/embeddings\", embeddingProxyHandler)\napp.get(\"/v1/models\", async (req) => Response.json(await models(req)))\napp.get(\"/v1/models/:model\", (c) => Response.json(modelDetail(c.params.model)))\napp.post(\"/:model_version/models/:model_and_action\", geminiProxy)\napp.all(\"*\", () => new Response(\"Page Not Found\", { status: 404 }))\n\nexport { app }\n", "import { serve } from \"@hono/node-server\"\nimport { app } from \"./src/app.ts\"\n\nconsole.log(\"Listening on http://localhost:8000/\")\nserve({\n  fetch: app.fetch,\n  port: 8000,\n})\n"],
  "mappings": "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",
  "names": ["crypto", "e", "Request", "cors", "options", "e", "Router", "base", "r", "routes", "other", "__proto__", "global", "e"]
}
